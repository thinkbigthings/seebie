# Seebie - Sleep Analysis Tool

This is a project to record and analyze your sleep.

## Prerequisites

Software that needs to be installed and available from the command line:

* Java 17
* Docker


### Install Java

Any major distribution of Java 17 should work. 
This project has been tested with openjdk 17.0.2 downloaded from https://adoptium.net/

### Install Docker

On Linux: `sudo apt install docker.io`
Note: On Linux, needed to run docker as sudo.
docker daemon must run as root, but you can specify that a group other than docker should own the Unix socket with the -G option.

On Mac: can install [Docker Desktop](https://hub.docker.com/editions/community/docker-ce-desktop-mac) or use brew.



# Database


## Docker Postgres for Development

This project uses [testcontainers](https://www.testcontainers.org) 
for integration tests as [recommended by Docker](https://www.docker.com/blog/maintainable-integration-tests-with-docker/).
"By spinning it up from inside the test itself, you have a lot more control over the orchestration and provisioning, 
and the test is more stable. You can even check when a container is ready before you start a test"

It turns out to be convenient to use test containers for general docker setup as well.
Running the full build with the server integration tests will create and populate
a docker container with a postgres database which can be left up and running after the build.

After a full build, the database should be in a state consistent with the data populated from the integration tests.
This can be useful for bringing up the application and exploring the data, e.g. for UI development.

Once running, connect to the db through docker directly:
`docker exec -it $(docker ps -q) bash` or `docker exec -it [container_name] bash`
then : `psql -U test`

or more succinctly:
`docker exec -it $(docker ps -q) psql -U test`

Handy Commands:

See running images with `docker ps`
Stop a container with `docker container stop container_name`

stop and remove all docker containers
`docker stop $(docker ps -q); docker rm $(docker ps -a -q)`


## Migrations

We use [Flyway](https://flywaydb.org) and run the migration standalone (not on default startup of the server)
so that we have more control over the migration process.

To perform a database migration, a server is run in a "migration only" mode that does the migrations and then shuts down.

e.g.

use `migrate` script that runs the migration profile with gradle,

or 

    cd server
    java --enable-preview -Dspring.profiles.active=migration -jar build/libs/server-1.0-SNAPSHOT.jar


## Threads

The Logging filter's ScheduledThreadPoolExecutor has a core pool size

The server defines a number of standard spring boot threads:
server.tomcat.max-threads
server.tomcat.min-spare-threads 
server.tomcat.accept-count


## HTTPS

We don't include the p12 file when deploying to heroku,
but get https by virtue of being a subdomain of herokuapps.com which has a CA cert.
Http automatically redirects to https on heroku.
The app is running on http on the inside of heroku. Check startup logs, see "tomcat running (http)"

`keytool` is called automatically at build time via the custom `genKey` task in build.gradle.
This way we don't need to commit certs to source control and the developer
does not need to generate keys for setup. In dev, we require https for everything.
The p12 file can be regenerated by simply deleting it (if the file already exists it is not regenerated).


To update HTTPS related files and properties, see the `server.ssl.*` properties used by Spring Boot

## Security

### Remember Me

The remember-me key is a secret and unique value. 
The value can be any string, but we can use a UUID for uniqueness and keep it secret.
It is sensitive information, so it should NOT be checked in to source control.

For tests, it is set to a dummy UUID value in test properties:

    app.security.rememberMe.key=0ef16205-ba16-4154-b843-8bd1709b1ef4

Since the test value is set inside the test configuration,
we do not need to set the value in GitHub Actions.

When running from the IDE it should be configured as an environment variable
in a Run/Debug Configuration in IntelliJ:

    APP_SECURITY_REMEMBERME_KEY = 0ef16205-ba16-4154-b843-8bd1709b1ef4 

Also, we can set it locally on the command line:

    export APP_SECURITY_REMEMBERME_KEY=0ef16205-ba16-4154-b843-8bd1709b1ef4 

We will also need to set this as an environment variable in the production environment.


## Email

With the spring mail library set as a dependency, and the mail properties set in application.properties,
the JavaMailSender is automatically configured and wired. We should not need to instantiate or configure
as a Bean separately unless there are very particular needs.

When spring automatically configures and wires the Mail classes, it also sets up a MailHealthIndicator.
This will attempt to test the connection during the actuator integration tests, and we do not need to send emails
at build time, so in general it is disabled as a health endpoint with `management.health.mail.enabled=false`

If using a Gmail account with 2FA, we can't just set the username/password in the mail properties.
An `App Password` needs to be generated. See https://support.google.com/accounts/answer/185833
(Note those directions apply to accounts with 2FA enabled, you should enable 2FA first if it isn't already)
Once generated, the user can be used with the app password and that should work without triggering the 2FA.

These credentials are sensitive information, so they should NOT be checked in to source control.
The email address and app password should be configured as environment variables:

    SPRING_MAIL_USERNAME
    SPRING_MAIL_PASSWORD

Can set them as environment variables in a Run/Debug Configuration in IntelliJ.
Also we can set these locally on the command line:

    export SPRING_MAIL_USERNAME=senderemail@gmail.com
    export SPRING_MAIL_PASSWORD=klmnopqrstuvwxyz

We will also need to set these as environment variables in the production environment.

Since we don't need to send emails at build time, we don't need to set these in Github Actions
although in principle we could set these as secrets assigned to environment variables.
See https://docs.github.com/en/actions/security-guides/encrypted-secrets


## Running

Doing a full build and leaving the docker container for postgres running
will allow us to run standalone.

## Debugging

Right click the main class and "Debug Application (main)"

## Testing



### Unit test
 
    gradlew test

### Integration Test

    gradlew integrationTest
    
### Both tests

    gradlew check
    
### Code Coverage

We can get code coverage metrics with Jacoco, and can do so for either unit tests, integration tests, or both.

    Generate coverage for just unit tests: `gradlew test`

    Generate coverage for just integration tests: `gradlew integrationTest`

    Generate coverage for all tests: `gradlew build`

Then see output in build/reports/jacoco/html/index.html


### Manual test

curl quick guide: https://gist.github.com/subfuzion/08c5d85437d5d4f00e58

#### Test admin functions and listing parameters

See most recent users:
`curl -k "https://localhost:9000/user?page=0&size=2&sort=registrationTime,desc"`

post:
`curl -k -X POST -H "Content-Type: application/json" -d '{"username":"user1", "displayName":"user1", "email":"us@r.com"}' https://localhost:9000/user`
or if the json is in a file:
`curl -k -X POST -H "Content-Type: application/json" -d @data-file.json https://localhost:9000/user`


#### Test Session Security

(this one should fail)
curl -kv --user user:password "https://localhost:9000/user/admin"

(this one should pass)
curl -kv --user admin:admin "https://localhost:9000/user/admin"

rm cookies.txt
curl -kv -b cookies.txt -c cookies.txt --user admin:admin "https://localhost:9000/login"
cat cookies.txt
curl -kv -b cookies.txt -c cookies.txt "https://localhost:9000/user/admin"
cat cookies.txt
curl -kv -b cookies.txt -c cookies.txt "https://localhost:9000/logout"
cat cookies.txt
curl -kv -b cookies.txt -c cookies.txt "https://localhost:9000/user/admin"
cat cookies.txt
rm cookies.txt

#### Test remember-me security

I think the parameter to trigger the remember-me functionality can be a url parameter.
Maybe also a request header but we haven't tested that.

    curl -i -u username:password "https://example.com/login?remember-me=true"


Manually demonstrate persistent login:

Start with a clean slate

    rm cookies.txt

Attempt to access secured endpoint while unauthenticated

    curl -kv  "https://localhost:9000/user/admin"

Login without remember-me and access secured endpoint

    curl -kv -b cookies.txt -c cookies.txt --user admin:admin "https://localhost:9000/login?remember-me=false"
    curl -kv -b cookies.txt -c cookies.txt "https://localhost:9000/user/admin"   

Wait for session timeout, then attempt to access secured endpoint

    curl -kv -b cookies.txt -c cookies.txt "https://localhost:9000/user/admin"

login with remember-me and access secured endpoint

    curl -kv -b cookies.txt -c cookies.txt --user admin:admin "https://localhost:9000/login?remember-me=true"
    curl -kv -b cookies.txt -c cookies.txt "https://localhost:9000/user/admin"

Wait for session timeout, then attempt to access secured endpoint again

    curl -kv -b cookies.txt -c cookies.txt "https://localhost:9000/user/admin"

Wait for remember-me timeout, then attempt to access secured endpoint again

    curl -kv -b cookies.txt -c cookies.txt "https://localhost:9000/user/admin"   


#### Test import / export

Can download all of your data like so:
`curl -kv --user myusername:password "https://localhost:9000/user/myusername/sleep/download" > seebie-data-heavyUser.csv`

Can upload the same data like so:
`curl -kv --user myusername:password -F 'file=@/Users/myusername/Downloads/seebie-data-myusername.csv' https://localhost:9000/user/myusername/sleep/upload`



### Web

Base URL is at https://localhost:9000/index.html

Static content (built JS, etc) should go into src/main/resources/static

## Actuator

For detailed help see the API docs https://docs.spring.io/spring-boot/docs/current/actuator-api/htmlsingle/#overview

Actuator endpoints are listed at e.g. `https://localhost:9000/actuator`

Some useful endpoints are `/actuator/health`, `/actuator/flyway`, `/actuator/info`

Git info is included under `actuator/info` and has a property to expose more details


## Update Dependencies

From this project, use `../gradlew dependencies`

Also see [Gradle Versions Plugin](https://github.com/ben-manes/gradle-versions-plugin)
To discover what dependencies are out of date.

To upgrade versions of Java in general:

- Note that Gradle's java toolchain feature allows us to run Gradle with one version and build with another version
  (useful if the current version of Gradle doesn't support the latest version of Java)
- Set the project base build.gradle's sourceCompatibility
- Update the server README that references Java version
- The heroku plugin also references the jdkVersion


To upgrade versions of Java in IntelliJ:

- I think you need to add the SDK in Module Settings -> Platform Settings -> SDK
  But see if updating Build Tools below works first
- Click "IntelliJ IDEA" -> Preferences -> Build, Execution, Deployment -> Build Tools -> Gradle
  and set Gradle JVM to the new version
- Might need to right click the project and go to module settings to set it there too?
- You'll also need to edit the version in any Run Configurations
