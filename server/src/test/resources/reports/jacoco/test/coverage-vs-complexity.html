<!DOCTYPE html>
<html>
<head>
    <title>Scatter Plot from CSV</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0"></script> <!-- For parsing CSV -->
</head>
<body>

<!-- This div centers the chart and sets its width -->
<div style="width: 70%; margin: 0 auto;">

    <h1>Complexity vs Coverage</h1>
    <p>
        This scatter plot shows the relationship between complexity and coverage for each class in the project,
        similar to that provided by
        <a href="https://openclover.org/doc/manual/latest/general--understanding-reports-dashboard-widgets.html">Clover</a>
    </p>
    <p>
        Why is this useful?
        This gives us ideas to explore. Ideally, we want to increase test coverage and reduce complexity,
        so put your attention on the classes towards the top and left,
        and work your way towards the bottom right corner.
    </p>

    <canvas id="scatterChart"></canvas>

</div>

<script>
    // Function to load CSV data
    function loadCSV(filePath) {
        return new Promise((resolve, reject) => {
            Papa.parse(filePath, {
                download: true,
                header: true, // Assumes first row is headers
                dynamicTyping: true, // Converts numeric fields to numbers
                complete: results => resolve(results.data),
                error: error => reject(error)
            });
        });
    }

    // Function to plot chart
    async function plotFromCSV() {
        const data = await loadCSV('jacocoTestReport.csv');

        // Step 1: Map the CSV data, the lines value will be added together so the radius of the bubble can be calculated
        const initialScatterData = data.map(row => ({
            x: 100 * row.INSTRUCTION_COVERED/(row.INSTRUCTION_COVERED + row.INSTRUCTION_MISSED),
            y: row.COMPLEXITY_COVERED + row.COMPLEXITY_MISSED,
            package: row.PACKAGE,
            classFile: row.CLASS,
            lines: (row.LINE_COVERED + row.LINE_MISSED),
        }));

        // Step 2: Accumulate sums of 'r' for each unique 'x' and 'y', all bubbles at the same point will be added together
        // so the bubble looks like the appropriate size for the amount of code that is actually there
        const rSums = {};
        initialScatterData.forEach(item => {
            const xyKey = `${item.x}-${item.y}`; // Create a unique key for each x-y pair
            rSums[xyKey] = (rSums[xyKey] || 0) + item.lines; // Sum the 'r' values
        });

        // Step 3: Update the 'r' values in the original mapped data
        const scatterData = initialScatterData.map(item => {
            const xyKey = `${item.x}-${item.y}`;
            const radius = Math.max(3, 1.2 * Math.sqrt(rSums[xyKey]))
            return { ...item, r: radius}; // Assign the summed lines value back to each item
        });

        new Chart(document.getElementById('scatterChart'), {
            type: 'bubble',
            data: {
                datasets: [{
                    label: 'Complexity vs Coverage',
                    data: scatterData,
                    backgroundColor: 'blue'
                }]
            },
            options: {
                scales: {
                    x: {
                        type: 'linear',
                        min: 0,
                        max: 100,
                        position: 'bottom',
                        title: {
                            display: true,
                            text: 'Coverage'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Complexity'
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                return label;
                            },
                            afterLabel: function(context) {
                                const coverageRounded = context.parsed.x.toFixed(2);
                                const detail = `Coverage: ${coverageRounded}%, Complexity: ${context.parsed.y}`;
                                const {package, classFile} = context.raw;
                                return [`${package}.${classFile}`, detail, ''];
                            }
                        }
                    }
                }
            }
        });
    }

    // Load and plot the CSV upon page load
    plotFromCSV();
</script>
</body>
</html>
